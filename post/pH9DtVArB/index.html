<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>iOS 国际化开发 | leixjin</title>
<link rel="shortcut icon" href="https://blog.xiaolei.kim/favicon.ico?v=1558864780614">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://blog.xiaolei.kim/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://blog.xiaolei.kim">
  <img class="avatar" src="https://blog.xiaolei.kim/images/avatar.png?v=1558864780614" alt="">
  </a>
  <h1 class="site-title">
    leixjin
  </h1>
  <p class="site-description">
    Think different.
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="https://blog.xiaolei.kim/post/tomyself/" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              iOS 国际化开发
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2016-04-25 ·
              </time>
              
                <a href="https://blog.xiaolei.kim/tag/aNq11Gn7A" class="post-tag">
                  # iOS
                </a>
              
            </div>
            
              <div class="post-feature-image" style="background-image: url('https://cdn.pixabay.com/photo/2016/02/27/18/05/forest-1225983_960_720.jpg')">
              </div>
            
            <div class="post-content">
              <p>一个iOS应用程序，如果想要在多个国家和地区的AppleStore上架，是很简单的一件事情。如果想要每个国家和地区的用户都能获得良好的使用体验，首先需要做的一件事情就是能够让用户打开App的第一时间，看到的是自己熟悉的语言。也就是说App能够根据用户当前所使用的语言或者用户手动选择的语言，实时的改变App内的语言。这就是iOS国际化所要实现的目的。</p>
<h1 id="国际化开发的两种情况">国际化开发的两种情况</h1>
<p>1.在App开发之初，就已经有了国际化开发的Future，这种情况下进行国际化是很容易的，只要在开发过程中把需要国际化的字符串进行简单的处理即可。</p>
<p>2.已经开发完毕，开发之初并没有进行国际化适配，突然来需求说需要进行国际化，此时面对项目中成百上千的字符串，内心一定是崩溃的。</p>
<p>接下来，我会分别对这两种情况来说一下开发过程。</p>
<blockquote>
<p><em>注:演示所使用的Xcode版本为7.3。</em></p>
</blockquote>
<h1 id="新启动的工程">新启动的工程</h1>
<h2 id="项目国际化配置">项目国际化配置</h2>
<p>1.找到Project的Localizations选项，点击加号(+)，添加需要国际化的语言(一般工程中默认支持英文，为了方便演示，我只添加了中文简体支持)。此时会弹出一个选择框，选择你所要支持的Xib文件或StoryBoard文件。不需要支持Xib或StoryBoard文件则不勾选。</p>
<blockquote>
<p>这里Use Base Internationalization开启状态下，每个国际化资源文件会有个Base选项，主要针对String，Xib，Storyboard作为一个基础的模板。</p>
</blockquote>
<p><img src="http://7xii6e.com1.z0.glb.clouddn.com/Localized_support.png" alt="是否添加Xib支持"></p>
<p><img src="http://7xii6e.com1.z0.glb.clouddn.com/Localized_add.png" alt="添加多语言支持"></p>
<p>2.创建多语言文件，一般命名为Localizable.string。如果在开发过程中不指定文件名，系统会默认在Bundle中寻找这个名称的文件。当然，也可以任意命名，在开发过程中手动指定一下文件名即可。</p>
<p><img src="http://7xii6e.com1.z0.glb.clouddn.com/Localized_string.png" alt="添加多语言文件"></p>
<p>3.找到并选中刚刚新建的Localizable.string文件，点击Inspector下Localization选项下的Localize按钮，任意选择一个语言(我选择的是English)，然后点击Localize按钮，此时Localization选项会出现应用支持的语言列表，选择需要国际化的语言，Localizable.string文件下则会多出和所选择语言对应的子文件。</p>
<p><img src="http://7xii6e.com1.z0.glb.clouddn.com/Localized_localized.png" alt="点击Localize按钮"></p>
<p><img src="http://7xii6e.com1.z0.glb.clouddn.com/Localized_localized_choose.png" alt="选择语言"></p>
<p><img src="http://7xii6e.com1.z0.glb.clouddn.com/Localized_localized_list.png" alt="出现语言列表"></p>
<p><img src="http://7xii6e.com1.z0.glb.clouddn.com/Localized_localized_LocalizationStrings.png" alt="添加需要国际化的语言"></p>
<h2 id="代码中对国际化内容的适配">代码中对国际化内容的适配</h2>
<p>1.我在ViewController中初始化了一个Label，并用NSLocalized宏对这个Label的字符串进行国际化适配。</p>
<pre><code class="language-objc">- (void)viewDidLoad {
    [super viewDidLoad];
    
    UILabel *localizationLabel = [[UILabel alloc] initWithFrame:CGRectMake(150, 200, 100, 20)];
    [self.view addSubview:localizationLabel];
    
    //利用NSLocalizedString宏对字符串进行国际化适配
    localizationLabel.text = NSLocalizedString(@&quot;Hello&quot;, @&quot;description for this key.&quot;);
    
}
</code></pre>
<p>既然用到了NSLocalizedString宏，我们就有必要了解一下这个宏到底干了什么。</p>
<h3 id="nslocalizedstring宏探秘">NSLocalizedString宏探秘</h3>
<p><strong>点进宏定义文件：</strong></p>
<pre><code class="language-objc">#define NSLocalizedString(key, comment) \
	    [[NSBundle mainBundle] localizedStringForKey:(key) value:@&quot;&quot; table:nil]
#define NSLocalizedStringFromTable(key, tbl, comment) \
	    [[NSBundle mainBundle] localizedStringForKey:(key) value:@&quot;&quot; table:(tbl)]
#define NSLocalizedStringFromTableInBundle(key, tbl, bundle, comment) \
	    [bundle localizedStringForKey:(key) value:@&quot;&quot; table:(tbl)]
#define NSLocalizedStringWithDefaultValue(key, tbl, bundle, val, comment) \
	    [bundle localizedStringForKey:(key) value:(val) table:(tbl)]
</code></pre>
<p><strong>我们会发现国际化相关所定义的4个宏。</strong></p>
<ul>
<li>NSLocalizedString(key, comment)</li>
</ul>
<p>NSLocalizedString其实是从mainBundle中默认读取了Localizable.string中的key所对应的value。comment参数则是对key的描述，有利于翻译人员理解这个key所适用的场景。</p>
<ul>
<li>NSLocalizedStringFromTable(key, tbl, comment)</li>
</ul>
<p>NSLocalizedStringFromTable则是从mainBundle中读取指定多语言文件中的key所对应的value。tbl参数就是用于指定多语言文件名的参数。</p>
<ul>
<li>NSLocalizedStringFromTableInBundle(key, tbl, bundle, comment)</li>
</ul>
<p>NSLocalizedStringFromTableInBundle会读取指定Bundle中所指定的多语言文件中的key所对应的value。bundle参数就是用于传入所指定的Bundle。</p>
<ul>
<li>NSLocalizedStringWithDefaultValue(key, tbl, bundle, val, comment)</li>
</ul>
<p>NSLocalizedStringWithDefaultValue则是从指定Bundle中读取指定多语言文件中的key所对应的value，如果取不到对应的value，允许指定一个默认的value。val参数就是用于传入默认的value值。</p>
<p>2.了解了各个宏定义所代表的含义，我们继续往下写。</p>
<p>在Localizable.strings(English)中加入如下键值对：</p>
<pre><code class="language-objc">&quot;Hello&quot; = &quot;Hello&quot;;

</code></pre>
<p>在Localizable.strings(Chinese(Simplified))中加入如下键值对：</p>
<pre><code class="language-objc">&quot;Hello&quot; = &quot;你好&quot;;
</code></pre>
<p><strong>编译运行：</strong></p>
<h3 id="系统语言为英文时显示效果">系统语言为英文时显示效果：</h3>
<p><img src="http://7xii6e.com1.z0.glb.clouddn.com/Localize:english.png" alt="英文运行结果"></p>
<h3 id="系统语言为中文时显示效果">系统语言为中文时显示效果：</h3>
<p><img src="http://7xii6e.com1.z0.glb.clouddn.com/Localize:chinese.png" alt="中文运行结果"></p>
<p>可见，文本会随着系统语言的改变而改变。至此，一个简单的可以跟随系统语言切换的Demo就完成了。</p>
<h1 id="已开发多个版本的工程">已开发多个版本的工程</h1>
<p>工程开发了许久，代码也写了几万行了，这时Boss突然说要进行国际化适配。</p>
<p>What the ***!!!</p>
<p>淡定，除了女朋友，还有什么能难道程序猿哥哥的事情呢？</p>
<p>下面开始。</p>
<h2 id="添加应用需要国际化的语言">添加应用需要国际化的语言</h2>
<p>在Project的Localizations选项，点击加号(+)，添加需要国际化的语言(一般工程中默认支持英文，为了方便演示，我只添加了中文简体支持)。</p>
<h2 id="批量替换字符串">批量替换字符串</h2>
<p>既然要在已有工程上进行适配，首先要做的就是给需要进行国际化的字符串加上NSLocalizedString宏了。</p>
<ul>
<li>2B程序猿</li>
</ul>
<p>会一处一处的修改每个文件的每处字符串，直到天荒地老、海枯石烂。</p>
<ul>
<li>非主流程序猿</li>
</ul>
<p>各种shell、Python脚本齐上阵。</p>
<ul>
<li>文艺程序猿</li>
</ul>
<p>Xcode大法好。正则大法好。</p>
<p>我选择第三种-。-</p>
<p>首先，我们需要一个正则，去匹配工程中所有需要替换的文本。如果你不太了解正则，<a href="http://deerchao.net/tutorials/regex/regex.htm">点我点我！！</a>。</p>
<p>下面这个正则可以匹配到所有符合OC字符串格式的包含有中文的字符串。如果你用Swift，请去掉<code>@</code>。</p>
<p><code>@&quot;[^&quot;]*[\u4E00-\u9FA5]+[^&quot;\n]*?&quot;</code></p>
<p>然后，重点来了。Command+Shift+F，进入全局搜索引擎，切换为Replace模式，并把匹配模式改为Regular Expression。</p>
<p>在搜索条件里输入<code>(@&quot;[^&quot;]*[\u4E00-\u9FA5]+[^&quot;\n]*?&quot;)</code>，在下面替换内容里输入<code>NSLocalizedString($1, nil)</code>。此处正则表达式两边加括号的目的是为了能够在替换时用<code>$1</code>获取原有字符串的值，在替换时把原有值放入宏定义内key的位置。然后，搜索，可以看到搜索结果，点击<code>Replace All</code>，即可完成替换。</p>
<p><img src="http://7xii6e.com1.z0.glb.clouddn.com/Localized%5Csearch.png" alt="正则搜索"></p>
<h2 id="生成多语言文件">生成多语言文件</h2>
<p>替换完了原有字符串，下面就是生成多语言文件了。作为一个文艺程序猿，我是不可能一处一处的把项目中的字符串挑出来再写到Localizable.strings文件里的。</p>
<p>好在Xcode自带了一个命令行工具genstrings。我们可以利用这个工具生成所需的多语言文件。</p>
<p>首先，我们需要先新建所需语言的文件夹。</p>
<pre><code class="language-shell">cd 工程目录
mkdir en.lproj
mkdir zh-Hans.lproj
</code></pre>
<p>然后，遍历所有<code>.m</code>文件，根据每个文件内的需要国际化的字符串生成key和value。</p>
<pre><code class="language-shell">find . -name *.m | xargs genstrings -o en.lproj
find . -name *.m | xargs genstrings -o zh-Hans.lproj
</code></pre>
<p>此时，<code>en.lproj</code>和<code>zh-Hans.lproj</code>文件夹中就应该有了相应的Localizable.string文件了。</p>
<p>我们把这两个文件夹拖到工程里，然后在相应的Localizable.strings文件中，修改每个key所对应的value值就行了(这个应该是翻译干的事儿)。</p>
<p>至此，项目的国际化已经适配完成。</p>
<h1 id="应用内动态更新语言">应用内动态更新语言</h1>
<p>以上所做的国际化，只会跟随系统语言进行改变，并且需要Kill掉App重新打开才会有效果。如果有一种需求，在应用内有一个语言列表，只要选中其中一种语言，点击确定后就能立刻更新应用内所有界面的语言，此时该怎么做呢？目前有好多大厂应用，比如微信、支付宝等都支持这种切换方式(微信和支付宝的实现方式不太一样，咱们稍后再叙)。</p>
<h2 id="替换系统国际化宏定义">替换系统国际化宏定义</h2>
<p>由系统宏定义可知，如果使用了系统的NSLocalizedString宏，它是默认是从mainBundle中读取Localizable.strings中的value的。使用其他的3个宏则可以指定文件名或是Bundle，但是使用起来也是不太灵活。为了使用起来更加方便灵活，我们可以自定义一个国际化的宏，实现其内部的逻辑。</p>
<p>下面，给出一种我自己的实现方式。</p>
<pre><code class="language-objc">//
//  LELocalizedHelper.h
//  Created by 金小白 on 16/4/23.
//  Copyright © 2016年 xiaolei.jin. All rights reserved.
//  国际化

#import &lt;Foundation/Foundation.h&gt;

#define LELocalizedString(key) [[LELocalizedHelper standardHelper] stringWithKey:key]

@interface LELocalizedHelper : NSObject

+ (instancetype)standardHelper;

- (NSBundle *)bundle;

- (NSString *)currentLanguage;

- (void)setUserLanguage:(NSString *)language;

- (NSString *)stringWithKey:(NSString *)key;

@end

</code></pre>
<pre><code class="language-objc">//
//  LELocalizedHelper.m
//  Created by 金小白 on 16/4/23.
//  Copyright © 2016年 xiaolei.jin. All rights reserved.
//  国际化

#import &quot;LELocalizedHelper.h&quot;

static NSBundle *_bundle;

static NSString *const kUserLanguage = @&quot;kUserLanguage&quot;;

@implementation LELocalizedHelper

+ (instancetype)standardHelper {
    static LELocalizedHelper *helper;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        helper = [[LELocalizedHelper alloc] init];
    });
    return helper;
}

- (instancetype)init {
    
    if (self = [super init]) {
        
        if (!_bundle) {
            
            NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
            
            NSString *userLanguage = [defaults valueForKey:kUserLanguage];
            
            //用户未手动设置过语言
            if (userLanguage.length == 0) {
                
                NSArray *languages = [[NSBundle mainBundle] preferredLocalizations];
                
                NSString *systemLanguage = languages.firstObject;
                
                userLanguage = systemLanguage;
            }
            
            if ([userLanguage isEqualToString:@&quot;zh-HK&quot;] || [userLanguage isEqualToString:@&quot;zh-TW&quot;]) {
                userLanguage = @&quot;zh-Hant&quot;;
            }
            
            NSString *path = [[NSBundle mainBundle] pathForResource:userLanguage ofType:@&quot;lproj&quot;];
            
            _bundle = [NSBundle bundleWithPath:path];
        }
        
    }
    return self;
}

- (NSBundle *)bundle {
    return _bundle;
}

- (NSString *)currentLanguage {
    
    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
    
    NSString *userLanguage = [defaults valueForKey:kUserLanguage];
    
    if (userLanguage.length == 0) {
        
        NSArray *languages = [[NSBundle mainBundle] preferredLocalizations];
        
        NSString *systemLanguage = languages.firstObject;
        
        return systemLanguage;
    }
    
    return userLanguage;
}

- (void)setUserLanguage:(NSString *)language {
    
    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
    
    NSString *path = [[NSBundle mainBundle] pathForResource:language ofType:@&quot;lproj&quot;];
    
    _bundle = [NSBundle bundleWithPath:path];
    
    [defaults setValue:language forKey:kUserLanguage];
    
    [defaults synchronize];
}

- (NSString *)stringWithKey:(NSString *)key {
    
    if (_bundle) {
        return [_bundle localizedStringForKey:key value:nil table:@&quot;Localizable&quot;];
    }else {
        return NSLocalizedString(key, nil);
    }
}

@end

</code></pre>
<p>使用的时候，只需把原来NSLocalizedString(key, nil)的地方替换为LELocalizedString(key)即可。此时如果用户没有手动更改过语言，默认是跟随系统语言变化的。</p>
<h2 id="动态刷新所有页面">动态刷新所有页面</h2>
<p>替换完了宏定义，下面就是全局刷新界面了。实现方式上来说，我目前共想出了3种，实现方式上来说各有优劣。</p>
<h3 id="重新载入rootviewcontroller">重新载入rootViewController</h3>
<p>这个方法应该是编码成本最低的方法了，只需要把原有的rootViewController移除并清空，然后重新设置一遍rootViewController就行了。但是这种实现方式会重新加载已经原来已经加载好的所有界面。</p>
<h3 id="语言改变发送通知">语言改变发送通知</h3>
<p>在用户切换语言的时候，发送一个通知，然后在各个界面接收通知，更新所有需要更新的文本即可。这种方法适合新建的项目，在代码编写之初就预留好更新文本的方法，收到通知后调用此方法就行。如果已经是一个已上线项目，则改动成本比较高，需要改动的地方比较多。</p>
<h3 id="h暴露一个更新文字的方法">.h暴露一个更新文字的方法</h3>
<p>在用户切换语言的时候，遍历所有已经加载的界面，调用更新文字的方法。这种实现也是比较适合新建的项目，在代码编写之初就预留好更新文本的方法。如果项目已上线，则改动成本较高。</p>
<p>上文说过，微信和支付宝的实现方式不太一样。根据我的观察和判断，微信使用的是上面的第一种方法，也就是重新载入rootViewController的方法。因为微信切换完语言之后，迅速的切换到了根页面，又迅速的push到了设置界面，有一个界面跳跃的过程，而且原来所有的已经滑到底部的列表全部都重置到了最顶部。根据我的推断，微信项目在编写之初也是没有考虑到后期国际化的需求，迫于过大的改动成本，只好使用第一种方法。而支付宝切换过程就比较完美，实现了无缝切换，和有可能是前期编码过程中就预留了更新文本的方法，后期直接调用就可以(不排除后期投入精力进行重构的可能)。</p>
<p>以上就是全部的iOS文字国际化的过程。</p>
<h1 id="图片国际化">图片国际化</h1>
<h2 id="网络图片国际化">网络图片国际化</h2>
<p>很简单，只要在请求的时候根据不同的语言环境调用不同的接口就可以。</p>
<h2 id="本地图片国际化">本地图片国际化</h2>
<p>本地图片的国际化也有两种实现方式。</p>
<h3 id="根据不同语言指定不同的图片名称">根据不同语言指定不同的图片名称</h3>
<p>这种方法可以在初始化图片名称的时候使用国际化宏定义，然后在对应语言的多语言文件中，根据图片对应的key指定相应语言的value即可。</p>
<h3 id="利用xcode生成">利用Xcode生成</h3>
<p>这种方法不用对代码进行改动，只需要在工程目录中新建一个Group，放入所有需要国际化的原有图片。然后选中图片，点击右侧的Localization，选中需要支持的语言即可在原有图片下生成选中语言所对应的子文件。然后替换掉对应语言的子图片即可。</p>
<blockquote>
<p>注：图片名必须和原有名字一致</p>
</blockquote>
<p><img src="http://7xii6e.com1.z0.glb.clouddn.com/Localized:localImage.png" alt="生成国际化图片"></p>
<p><img src="http://7xii6e.com1.z0.glb.clouddn.com/Localized:localImageList.png" alt="国际化图片列表"></p>
<p><img src="http://7xii6e.com1.z0.glb.clouddn.com/Localized:image:english.png" alt="英文图片"></p>
<p><img src="http://7xii6e.com1.z0.glb.clouddn.com/Localized:image:chinese.png" alt="中文图片"></p>
<p>这样，在更改系统语言的时候，图片也会随之改变了。</p>
<p>以上就是我总结的所有的有关iOS国际化的操作了，如果有疏漏的地方，请各位看官多多指正。共勉。</p>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://blog.xiaolei.kim/post/jCdw3cGbP">
              <h3 class="post-title">
                Hexo 在部署时忽略 README 文件的渲染
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://blog.xiaolei.kim/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
